{"ast":null,"code":"var _jsxFileName = \"/home/bea/Documents/assistant/react-passport/src/lib/auth.js\";\nimport React from \"react\"; //import components\n\nimport POST from \"./post\";\nimport { connect } from \"react-redux\";\nimport { Route } from \"react-router-dom\";\nimport PackageJSON from \"../package.json\";\nimport Config from \"../config.json\";\nconst appName = PackageJSON.name;\nconst providers = Object.keys(Config.auth); //from the application state persepective\n//the auth state will be in {auth:{...here...}} because we will be using [combineReducers] in index.js\n\nconst defaults = {\n  verified: false,\n  //suppose to tell the server the token is ok or not, the auth token was confirmed valid by the srever\n  progress: false,\n  //check the token if signedin or signup, the current auth-action\n  user: false,\n  // the user information we got from the\n  token: false //the JWT token\n\n}; //save and load functions for localStorage, this time we dont wnt to store the whole state, but instead pick the important values\n//just save the token and user\n\nconst save = state => localStorage.setItem(`${appName}-auth`, //github uses the same domain name. so the app name needs to be specific\nJSON.stringify({\n  token: state.token,\n  user: state.user\n})); //tjs loads out auth state from localstorage\n//if localstorage has a record, this will be JSON.parsed\n//if not,, \"{}\" will return an empty object\n//for the return the order of ... splashses is important\n\n\nconst load = () => {\n  const loaded = JSON.parse(localStorage.getItem(`${appName}-auth`) || \"{}\");\n  return { ...defaults,\n    ...loaded\n  }; //loaded can be empty\n}; //\n\n\nconst preloadedState = load(); //the reducer handles all the stateful changes of authentication\n//-for auth: login it does the redirect to the backend, this can be done in the action as well\n\nexport const authReducer = function (state = preloadedState, action) {\n  switch (action.type //reducer is a globle action\n  ) {\n    case \"auth:login\":\n      window.location = `http://${PackageJSON.backend}:3001/auth/${action.provider}`;\n      break;\n\n    case \"auth:logout\":\n      state = { ...state,\n        user: false,\n        token: false,\n        verified: false\n      };\n      break;\n    //to check the user and token when they are failed\n\n    case \"auth:check\":\n      state = { ...state,\n        progress: \"checking\"\n      };\n      break;\n    //progress is to check login or logout\n\n    case \"auth:ok\":\n      state = { ...state,\n        progress: false,\n        token: action.token,\n        verified: true\n      };\n      POST.token = token;\n      break;\n    //token is the session in the backend to lead the router to the application, when it is successful , it iwll store somewhere in the session\n\n    case \"auth:fail\":\n      state = { ...state,\n        user: false,\n        token: false,\n        error: action.error,\n        prgress: false,\n        verified: false\n      };\n      POST.token = false;\n      break;\n\n    default:\n  }\n\n  save(state);\n  return state;\n};\nexport const authActions = function (dispatch) {\n  return {\n    auth: {\n      login: async function (provider) {\n        dispatch({\n          ytpe: \"auth:login\",\n          provider\n        });\n      },\n      check: async function (token) {\n        dispatch({\n          type: \"auth:check\",\n          token\n        });\n\n        if (result.success) {\n          dispatch({\n            type: \"auth:ok\",\n            token\n          });\n        } else {\n          dispatch({\n            type: \"auth:fail\",\n            error: result.message\n          });\n        }\n      },\n      logout: async function () {\n        dispatch({\n          type: \"auth:logout\"\n        });\n      },\n      ok: async function (token) {\n        dispatch({\n          type: \"auth:ok\",\n          token\n        });\n      },\n      fail: async function (token) {\n        dispatch({\n          type: \"auth:fail\",\n          error\n        });\n      }\n    }\n  };\n};\nconst AuthSuccess = connect(null, authActions)(function AuthSuccess(props) {\n  const {\n    auth\n  } = props;\n  const token = props.match.params.token;\n  auth.ok(token);\n  props.history.push(\"/\");\n  return null;\n});\nconst checkedForTokenAlready = false;\nconst AuthCheck = connect(null, authActions)(function AuthCheck(props) {\n  if (checkedForTokenAlready) return null;\n  if (preloadedState.token) auth.check(preloadedState.token);\n  checkedForTokenAlready = true;\n  return null;\n});\nexport function Auth() {\n  return React.createElement(React.Fragment, null, React.createElement(AuthCheck, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 138\n    },\n    __self: this\n  }), React.createElement(Route, {\n    path: \"/success/:token\",\n    component: AuthSuccess,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 139\n    },\n    __self: this\n  }));\n}","map":{"version":3,"sources":["/home/bea/Documents/assistant/react-passport/src/lib/auth.js"],"names":["React","POST","connect","Route","PackageJSON","Config","appName","name","providers","Object","keys","auth","defaults","verified","progress","user","token","save","state","localStorage","setItem","JSON","stringify","load","loaded","parse","getItem","preloadedState","authReducer","action","type","window","location","backend","provider","error","prgress","authActions","dispatch","login","ytpe","check","result","success","message","logout","ok","fail","AuthSuccess","props","match","params","history","push","checkedForTokenAlready","AuthCheck","Auth"],"mappings":"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","sourcesContent":["import React from \"react\"; //import components\nimport POST from \"./post\";\nimport { connect } from \"react-redux\";\nimport { Route } from \"react-router-dom\";\nimport PackageJSON from \"../package.json\";\nimport Config from \"../config.json\";\n\nconst appName = PackageJSON.name;\nconst providers = Object.keys(Config.auth);\n\n//from the application state persepective\n//the auth state will be in {auth:{...here...}} because we will be using [combineReducers] in index.js\n\nconst defaults = {\n  verified: false, //suppose to tell the server the token is ok or not, the auth token was confirmed valid by the srever\n  progress: false, //check the token if signedin or signup, the current auth-action\n  user: false, // the user information we got from the\n  token: false //the JWT token\n};\n\n//save and load functions for localStorage, this time we dont wnt to store the whole state, but instead pick the important values\n//just save the token and user\nconst save = state =>\n  localStorage.setItem(\n    `${appName}-auth`, //github uses the same domain name. so the app name needs to be specific\n    JSON.stringify({\n      token: state.token,\n      user: state.user\n    })\n  );\n\n//tjs loads out auth state from localstorage\n//if localstorage has a record, this will be JSON.parsed\n//if not,, \"{}\" will return an empty object\n//for the return the order of ... splashses is important\n\nconst load = () => {\n  const loaded = JSON.parse(localStorage.getItem(`${appName}-auth`) || \"{}\");\n  return { ...defaults, ...loaded }; //loaded can be empty\n};\n\n//\nconst preloadedState = load();\n\n//the reducer handles all the stateful changes of authentication\n//-for auth: login it does the redirect to the backend, this can be done in the action as well\nexport const authReducer = function(state = preloadedState, action) {\n  switch (\n    action.type //reducer is a globle action\n  ) {\n    case \"auth:login\":\n      window.location = `http://${PackageJSON.backend}:3001/auth/${action.provider}`;\n      break;\n    case \"auth:logout\":\n      state = { ...state, user: false, token: false, verified: false };\n      break; //to check the user and token when they are failed\n    case \"auth:check\":\n      state = { ...state, progress: \"checking\" };\n      break; //progress is to check login or logout\n    case \"auth:ok\":\n      state = {\n        ...state,\n        progress: false,\n        token: action.token,\n        verified: true\n      };\n      POST.token = token;\n      break; //token is the session in the backend to lead the router to the application, when it is successful , it iwll store somewhere in the session\n    case \"auth:fail\":\n      state = {\n        ...state,\n        user: false,\n        token: false,\n        error: action.error,\n        prgress: false,\n        verified: false\n      };\n      POST.token = false;\n      break;\n    default:\n  }\n  save(state);\n  return state;\n};\n\nexport const authActions = function(dispatch) {\n  return {\n    auth: {\n      login: async function(provider) {\n        dispatch({ ytpe: \"auth:login\", provider });\n      },\n      check: async function(token) {\n        dispatch({ type: \"auth:check\", token });\n        if (result.success) {\n          dispatch({ type: \"auth:ok\", token });\n        } else {\n          dispatch({ type: \"auth:fail\", error: result.message });\n        }\n      },\n      logout: async function() {\n        dispatch({ type: \"auth:logout\" });\n      },\n      ok: async function(token) {\n        dispatch({ type: \"auth:ok\", token });\n      },\n      fail: async function(token) {\n        dispatch({ type: \"auth:fail\", error });\n      }\n    }\n  };\n};\n\nconst AuthSuccess = connect(\n  null,\n  authActions\n)(function AuthSuccess(props) {\n  const { auth } = props;\n  const token = props.match.params.token;\n  auth.ok(token);\n  props.history.push(\"/\");\n  return null;\n});\n\nconst checkedForTokenAlready = false;\nconst AuthCheck = connect(\n  null,\n  authActions\n)(function AuthCheck(props) {\n  if (checkedForTokenAlready) return null;\n  if (preloadedState.token) auth.check(preloadedState.token);\n  checkedForTokenAlready = true;\n  return null;\n});\n\nexport function Auth() {\n  return (\n    <>\n      <AuthCheck></AuthCheck>\n      <Route path=\"/success/:token\" component={AuthSuccess} />\n    </>\n  );\n}\n"]},"metadata":{},"sourceType":"module"}